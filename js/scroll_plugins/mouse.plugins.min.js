/* http://james.padolsey.com/javascript/special-scroll-events-for-jquery/ */
/**
 * Crear evento de mouseover wheel un tiempo de espera 
 * Utilizar como:
 * 
 * $("#your-div").bind( "mousewheelactivity", {data}, function( evt, type_evt, delta, deltaX, deltaY ){  });
 * $("#your-div").mousewheelactivity( function( evt, type_evt, delta, deltaX, deltaY ){  }, {data} );
 * $("#your-div").mouseactivity( "start,stop,mousewheel", fn, data, namespace );
 * 
 * $("#your-div").unbind( "mousewheelactivity", fn );
 * $("#your-div").unmousewheelactivity( fn );
 * $("#your-div").unmouseactivity( namespace );
 *
 * O utilizarlo asi
 * 
 * $("#your-div").bind("mousewheel", {data}, function( evt, delta, deltaX, deltaY ){  })
 * $("#your-div").mousewheel( function( evt, delta, deltaX, deltaY ){  }, {data} );
 *
 * Y para eliminarlo lo puedes hacer así
 *
 * $("#your-div").unbind( "mousewheel", fn )
 * $("#your-div").unmousewheel( fn );
 *
 * y también lo puedes utilizar los siguientes eventos
 * para determinar cuando empieza la actividad del scroll con un tiempo de espera
 *
 * $("#your-div").bind("scrollstart", {data}, function( evt ){  })
 * $("#your-div").scrollstart( function( evt ){  }, {data} );
 *
 * Evento cuando el scroll se para despues de una accion.
 * $("#your-div").bind("scrollstop", {data}, function( evt ){  })
 * $("#your-div").scrollstop( function( evt ){  }, {data} );
 *
 */
 
( function( $ ){
    
    var special = jQuery.event.special,
		types = ['DOMMouseScroll', 'mousewheel'];
        
    special.scrollstart = {
		// Id único del evento
		guid : 'D' + ( +new Date() ),
		
		// Configuración del evento
		_settings : {
			// Latencia para que el lanzar el evento
			latency: 300,
			
			// Nombre del evento
			evt_type : "scrollstart"
		},
		
        setup: function( options, namespaces, eventHandle ) {
            // Obtener la configuracion.
			var _opt = $.extend( {}, special.scrollstart._settings, options || {} ),
            
				timer,
				
                handler =  function( evt ) {
                    
                    var _self = this,
                        _args = arguments;
                    
                    if (timer) {
                        clearTimeout(timer);
                    } else {
                        evt.type = _opt.evt_type;
                        ( jQuery.event.dispatch || jQuery.event.handle ).apply(_self, _args);
                    }
                    
                    timer = setTimeout( function(){ timer = null; }, _opt.latency );
                    
                };
            
            jQuery(this).bind('scroll', handler).data( special.scrollstart.guid, handler);
        },
		
        teardown: function( namespaces ){
			// Eliminar eventos
            jQuery(this).unbind( 'scroll', jQuery(this).data( special.scrollstart.guid ) );
        }
    };
    
	/*** Crear evento de mouseover con un tiempo de espera ***/
	special.mouseoverstop = {
		// Id único del evento 
		guid : 'D' + ( +new Date() * 2 ),
		
		// Configuración del evento
		_settings : {
			// Latencia para que el lanzar el evento
			latency: 600,
			
			// Nombre del evento
			evt_type : "mouseoverstop"
		},
		
		/*** Instalar el evento ***/
        setup: function( options, namespaces, eventHandle ) {
            /*** Vars ****/
            var timer, _opt = $.extend( {}, special.mouseoverstop._settings, options || {} ),
				/*** mouseover ***/
                handler =  function(evt) {
                    /*** Vars ****/
                    var _self = this,
                        _args = arguments;
						
                    /*** Check if exist the setTime ****/
                    if ( timer ) {
                        clearTimeout(timer);
                    }
                    
                    timer = setTimeout( function(){                        
						timer = null;
						evt.type = _opt.evt_type;
						
						// Llamar evento
                        ( jQuery.event.dispatch || jQuery.event.handle ).apply( _self, _args );
						
                    }, _opt.latency);
                    
                },
				/*** mouseout ***/
				handler_out = function(evt){
					/*** Check if exist the setTime ****/
					if (timer) {
                        clearTimeout(timer);
                    }
				};
				
            /*** Asignar evento ****/
            jQuery(this).bind('mouseover', handler).data( special.mouseoverstop.guid, handler);
			jQuery(this).bind('mouseout', handler_out).data( special.mouseoverstop.guid + "2", handler_out);
        },
        teardown: function( namespaces ){
			/*** Eliminar evento ***/
            jQuery(this).unbind('mouseover', jQuery(this).data( special.mouseoverstop.guid ) );
			jQuery(this).unbind('mouseout', jQuery(this).data( special.mouseoverstop.guid + "2" ) );
        }
    };
	
    special.scrollstop = {
		// Id único del evento  ( function(){ return 'D' + (+new Date() + 1); })()
		guid : 'D' + ( +new Date() * 3 ),
				
		// Configuración del evento
		_settings : {
			// Latencia para que el lanzar el evento
			latency: 300,
			
			// Nombre del evento
			evt_type : "scrollstop"
		},
		
		_debug : function(){
			/* Mostrar argumentos...*
			if ( window.console && window.console.log )
				console.log( arguments ); /**/
		},
		
		// Instalar evento
        setup: function( options, namespaces, eventHandle ) {
			// called once per an element
			special.scrollstop._debug( "setup ->", arguments );
			
            // Obtener la configuracion.
			var _opt = $.extend( {}, special.scrollstop._settings, options || {} ),
				
				timer,
                
				handler = function( evt ) {
                    // vars
                    var _self = this,
                        _args = arguments;
                    
                    if ( timer ) {
                        clearTimeout( timer );
                    }
                    
                    timer = setTimeout( function(){
                        
                        timer = null;
                        evt.type = _opt.evt_type;
						
						// Llamar evento
                        ( jQuery.event.dispatch || jQuery.event.handle ).apply( _self, _args );
                        
                    }, _opt.latency );                    
                };
            
            jQuery( this ).bind( 'scroll', handler ).data( special.scrollstop.guid, handler );
        },
		
        teardown: function( namespaces ) {
			// called once per an element
			special.scrollstop._debug( "teardown ->", arguments );
			
            jQuery( this ).unbind( 'scroll', jQuery( this ).data( special.scrollstop.guid ) );
        },
		
		add: function( handleObj ) {
       		// called for each bound handler
			special.scrollstop._debug( "add ->", arguments );
    	},
		
		remove: function( handleObj ) {
        	// called for each bound handler
			special.scrollstop._debug( "remove ->", arguments );
		}
	};
    	
   /*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
	* Licensed under the MIT License (LICENSE.txt).
	*
	* Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
	* Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
	* Thanks to: Seamus Leahy for adding deltaX and deltaY
	*
	* Version: 3.0.6
	* 
	* Requires: 1.2.2+
	*/
	if ( jQuery.event.fixHooks ) {
		for ( var i=types.length; i; ) {
			jQuery.event.fixHooks[ types[--i] ] = jQuery.event.mouseHooks;
		}
	}

	special.mousewheel = {
		// Id único del evento 
		guid : 'D' + ( +new Date() * 4 ),
		
		// Configuración del evento
		_settings : {			
			// Nombre del evento
			evt_type : "mousewheel"
		},
		
		/*** Instalar el evento ***/
		setup: function( options, namespaces, eventHandle ) {
			/*** Vars ****/
            var timer, _opt = $.extend( {}, special.mousewheel._settings, options || {} ),
				
			    /*** mousewheel ****/
				handler_mousewheel = function ( event ) {
					/**** event ****/
					var orgEvent = event || window.event,
						args = [].slice.call( arguments, 1 ),
						delta = 0, returnValue = true,
						deltaX = 0, deltaY = 0,
						
						/*** Vars ***/
                    	_self = this, _args = arguments;
						
					event = jQuery.event.fix( orgEvent );
					event.type = _opt.evt_type;
					
					// Old school scrollwheel delta
					if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta / 120; }
					if ( orgEvent.detail     ) { delta = -orgEvent.detail / 3; }
					
					// New school multidimensional scroll (touchpads) deltas
					deltaY = delta;
					
					/**** Gecko ****/
					if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
						deltaY = 0;  deltaX = -1 * delta;
					}
					
					// Webkit
					if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY / 120; }
					if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX / 120; }
					
					// Add event and delta to the front of the arguments
					args.unshift( event, delta, deltaX, deltaY );	
					
					// Llamar evento				
					return ( jQuery.event.dispatch || jQuery.event.handle ).apply(this, args);
				};
	
			/**** mousewheel ****/
			if ( this.addEventListener ) {
				/*** Asignar eventos ****/
				for ( var i=types.length; i; ) this.addEventListener( types[--i], handler_mousewheel, false );
				
			} else {
				/** IE/Opera. */
				this.onmousewheel = handler_mousewheel;
			}
			
			/**** Guardar datos ***/
			jQuery( this ).data( special.mousewheel.guid, handler_mousewheel );
		},
		
		teardown: function( namespaces ) {
			/**** mousewheel ****/
			if ( this.removeEventListener ) {
				/*** Eliminar eventos ****/
				for ( var i=types.length; i; )
					this.removeEventListener( types[--i], jQuery( this ).data( special.mousewheel.guid ), false );				
			} else {
				this.onmousewheel = null;
			}
		}	
	}
	
   /**
	* Crear un evento lanzado cuando el evento mousewheel tiene una actividad
	*/
	special.mousewheelactivity = {
		// Id único del evento 
		guid : 'D' + ( +new Date() * 5 ),
		
		// Configuración del evento
		_settings : {			
			// Nombre del evento
			event_type : {
				start : "start",
				stop : "stop",
				_default : "mousewheel"
			}, 
						
			/*** Tiempo de espera para lanzar el evento ***/
			latency: 1000,
			
			// Tener en cuenta también el mouseover
			mouseover : false
		},
		
		/*** Instalar el evento ***/
        setup: function( options, namespaces, eventHandle ) {
            /*** Vars ****/
            var timer, _opt = $.extend( {}, special.mousewheelactivity._settings, options || {} ),
				/*** mouseover ***/
                handler =  function( evt ) {
                    /*** Vars ***/
                    var _self = this,
                        _args = arguments;
					
					return _opt.mouseover ? jQuery( this ).trigger( "mousewheel" ) : _self;
                },
				
				/*** Actividad del mouse ***/
				mouse_activity = function( evt ){
					/*** Vars ***/
                    var _self = this, new_arg,
                        _args = arguments;
					
					/*** Check if exist the setTime ****/					
					if ( timer ) {
						/*** Elimino intervalo ****/
                        clearTimeout( timer );						
						
					} else {
						/*** Llamar evento cuando el mousewheel empieza ****/
						evt.type = "mousewheelactivity";
						
						// Organizar parametros...
						new_arg = [ evt, _opt.event_type.start ];

						// Call function.
						( jQuery.event.dispatch || jQuery.event.handle ).apply( _self, new_arg );
					}
					
					timer = setTimeout( function(){                        
						/*** ejecuto el evento cuando el mousewheel términa. ****/
						timer = null;  evt.type = "mousewheelactivity";
						
						// Organizar parametros...
						new_arg = [ evt, _opt.event_type.stop ];
						
						// LLamar evento
                        ( jQuery.event.dispatch || jQuery.event.handle ).apply( _self, new_arg );

                    }, _opt.latency ); 
					
					// Llamar evento de mousewheel
					if( typeof evt == "object" && evt.type == "mousewheel" && _args.length == 4 ){
						// Actualizar nombre del evento
						evt.type = "mousewheelactivity";
						
						// Organizar parametros...
						new_arg = [].slice.call( arguments, 1 );
						new_arg.unshift( evt, _opt.event_type._default );
						
						// Llamar evento.
                        ( jQuery.event.dispatch || jQuery.event.handle ).apply( _self, new_arg );
					}
				};
				
            /*** Asignar eventos ****/            
			jQuery( this ).bind('mousewheel', mouse_activity ).data( special.mousewheelactivity.guid, mouse_activity );
			jQuery( this ).bind('mouseover', handler ).data( special.mousewheelactivity.guid + "2", handler );
        },
		
        teardown: function( namespaces ){
			/*** Eliminar eventos ***/
            jQuery( this ).unbind('mouseover', jQuery(this).data( special.mousewheelactivity.guid + "2" ) );
			jQuery( this ).unbind('mousewheel', jQuery(this).data( special.mousewheelactivity.guid ) );
        }
    };


   /**
	* Crear un evento lanzado cuando el usuario deja de escribir
	*/
	special.activitykey = {
		// Id único del evento 
		guid : function( ){
			// Return
			return 'AK' + ( +new Date() * 6 );		
		},
		
		// Configuración del evento
		_settings : {
			// Latencia para que el lanzar el evento
			latency		: 800,
			
			// Tener en cuenta estos eventos
			keypress	: false,
			keyup		: false,
			keydown		: true,
			
			// Nombre del evento
			evt_type : "activitykey"
		},
		
		_debug : function(){
			/* Mostrar argumentos... **
			if ( window.console && window.console.log )
				console.log( arguments );*/ 
		},
		
		// Instalar evento
        setup: function( options, namespaces, eventHandle ) {
			// called once per an element
			special.activitykey._debug( "setup ->", arguments );
        },
				
		add: function( handleObj ) {
       		// called for each bound handler
			special.activitykey._debug( "add ->", arguments );
			
			// Obtener la configuracion.
			var _options = handleObj.data,	namespace = handleObj.namespace || "",
				_opt = $.extend( {}, special.activitykey._settings, _options || {} ),  timer,
				
				// Recuperar datos
				_data = jQuery( this ).data( "activitykey" ), _obj = [],
				
				// guid
				_gid = special.activitykey.guid( ),				
                
				handler = function( evt ) {
                    // vars
                    var _self = this,	new_arg,
                        _args = arguments;					
					
                    if ( timer ) {
						// Eliminar
                        clearTimeout( timer );
						
						/*** Llamar evento cuando el evento continua ****/
						evt.type = _opt.evt_type;
						
						// Organizar parametros...
						new_arg = [ evt, "keyactivity" ];

						// Call function.
						( jQuery.event.dispatch || jQuery.event.handle ).apply( _self, new_arg );
						
					} else {
						/*** Llamar evento cuando el evento empieza ****/
						evt.type = _opt.evt_type;
						
						// Organizar parametros...
						new_arg = [ evt, "start" ];

						// Call function.
						( jQuery.event.dispatch || jQuery.event.handle ).apply( _self, new_arg );
					}

                    timer = setTimeout( function(){
                        // Eleminar setTime
                        timer = null;
                        evt.type = _opt.evt_type;
						
						// Organizar parametros...
						new_arg = [ evt, "stop" ];
						
						// LLamar evento
                        ( jQuery.event.dispatch || jQuery.event.handle ).apply( _self, new_arg );
                        
                    }, _opt.latency );
            	};
			
			_obj = ( typeof _data == "object" && $.isArray( _data ) ) ? _data : _obj;
			
			// Agregar
			var _add = {
				_handler	: handler,
				_options	: _opt,
				_guid		: _gid,
				_namespace	: namespace
			};	
			
			// add object
			_obj.push( _add );
			
			// Guardar datos - special.activitykey.guid
			jQuery( this ).data( "activitykey", _obj );
			handleObj["activitykey"] = _add;	handleObj["_guid"] = _gid;
			
			// Asignar eventos
            if( _opt.keyup ) jQuery( this ).bind( "keyup." + _gid, handler );
			if( _opt.keypress ) jQuery( this ).bind( "keypress." + _gid, handler );
			if( _opt.keydown ) jQuery( this ).bind( "keydown." + _gid, handler );
    	},
		
		teardown: function( namespaces ) {
			// called once per an element
			special.activitykey._debug( "teardown ->", arguments );
			
			// Eliminar data
			jQuery( this ).removeData( "activitykey" );
        },

		remove: function( handleObj ) {
        	// called for each bound handler
			special.activitykey._debug( "remove ->", arguments );
			
			// Obtener id
			var _gid = handleObj._guid,
				activitykey = handleObj.activitykey;
			
			//Eliminar eventos /**/
            jQuery( this ).unbind( "keyup." + _gid );
			jQuery( this ).unbind( "keypress." + _gid );
			jQuery( this ).unbind( "keydown." + _gid );
		},
		
		trigger: function( handleObj ){
			// Called when the .trigger() or .triggerHandler() methods
			special.activitykey._debug( "trigger ->", arguments );
			
			var data = jQuery( this ).data( ),	__f = false,
				namespace = handleObj.namespace || "", self = this,
				
				// Llama la función
				_funtionTrigger = function( _nsc, _opt, _self, _guid, v ) {
					// Seleccionar evento					
					if( _opt.keyup ){
						// Capturar evento
						__f = "keyup";
						
					} else if( _opt.keypress ){
						// Capturar evento
						__f = "keypress";
						
					} else if( _opt.keydown ){
						// Capturar evento
						__f = "keydown";						
					}
					
					// Llamar funtion
					if( __f && v._handler && $.isFunction( v._handler ) ){						
						// Argumentos
						var _args = [ handleObj, v ];
						
						// Invocar evento
						v._handler.apply( _self, _args );
					}
				};

			if( !( typeof data === "object" && data.activitykey && $.isArray( data.activitykey ) ) ) return false;
			
			$.each( data.activitykey, function( i, v ){
				// Llamar funciones
				if( namespace === v._namespace ){
					// Llamar función
					_funtionTrigger( v._namespace, v._options, self, v._guid, v );
				}
			});
			
			return false;
		}
    };

	
	jQuery.fn.extend({
		// Asignar evento del mousewheel
		mousewheel: function( fn, evt_sttg ) {
			return fn ? this.bind( "mousewheel", evt_sttg || {}, fn ) : this.trigger( "mousewheel" );
		},
		// Eliminar evento del mousewheel
		unmousewheel: function( fn ) {
			return this.unbind( "mousewheel", fn );
		},
		
		// Asignar evento del scrollstop
		scrollstop : function( fn, evt_sttg ) {
			return fn ? this.bind( "scrollstop", evt_sttg || {}, fn ) : this.trigger( "scrollstop" );
		},
		// Eliminar evento del scrollstop
		unscrollstop: function( fn ) {
			return this.unbind( "scrollstop", fn );
		},
		
		// Asignar evento del scrollstart
		scrollstart : function( fn, evt_sttg ) {
			return fn ? this.bind( "scrollstart", evt_sttg || {}, fn ) : this.trigger( "scrollstart" );
		},
		// Eliminar evento del scrollstart
		unscrollstart: function( fn ) {
			return this.unbind( "scrollstart", fn );
		},
		
		// Asignar evento del mouseoverstop
		mouseoverstop: function( fn, evt_sttg ) {
			return fn ? this.bind( "mouseoverstop", evt_sttg || {}, fn ) : this.trigger( "mouseoverstop" );
		},
		// Eliminar evento del mouseoverstop
		unmouseoverstop: function( fn ) {
			return this.unbind( "mouseoverstop", fn );
		},
		
		// Asignar evento del mouse
		mousewheelactivity : function( fn, evt_sttg ) {
			return fn ? this.bind( "mousewheelactivity", evt_sttg || {}, fn ) : this.trigger( "mousewheelactivity" );
		},
		// Eliminar evento del mouse
		unmousewheelactivity: function( fn ) {
			return this.unbind( "mousewheelactivity", fn );
		},
		
		// Asignar evento del teclado
		activitykey : function( fn, evt_sttg ) {
			return fn ? this.bind( "activitykey", evt_sttg || {}, fn ) : this.trigger( "activitykey" );
		},
		
		// Eliminar evento del teclado
		unactivitykey: function( fn ) {
			return this.unbind( "activitykey", fn );
		},
		
		
		// Cuando la actividad del mousewheel se detiene
		mouseactivity : function( fn_name, fn, data, namespace ){
			// Comprobar si es una funcion válida
			if ( !$.isFunction( fn ) ) return this;
			
			namespace = ( !namespace || namespace == "" ) ? "__mouseactivity" : namespace;
			
			// Nombre de las funciones
			var functions = ( fn_name || "" ).split( "," ),
				
				check = function( evt, type_evt, delta, deltaX, deltaY ){
					// Elemento
					var _self = this,
						_arg = arguments;
					
					// verificar si la funcion esta en el evento.
					if( $.inArray( type_evt, functions ) != -1 ){
						// Llamar funcion.
						fn.apply( _self, _arg );
					}								
				};			
			
			// Asignar eventos
			return this.bind( "mousewheelactivity", data || {}, check ).data( namespace, check );
		},
		
		unmouseactivity : function( namespace ){
			// Recuperar nombre...
			namespace = ( !namespace || namespace == "" ) ? "__mouseactivity" : namespace;

			// Eliminar funciones
			return this.unmousewheelactivity( this.data( namespace ) ).removeData( namespace );
		}
	});
    
})( jQuery );